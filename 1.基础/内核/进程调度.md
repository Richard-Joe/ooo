# 进程调度

## 1. 概览

### 1.1. 什么是调度

调度是CPU资源管理器。所有进程的运行都需要CPU，对CPU该如何管理呢？

一般有两种管理方法：一种是`时间分割管理`，另一种是`空间分割管理`。

由于CPU自身的特性，没有空间分割相似性，只有时间分割相似性，所以我们只能对CPU进行时间分割管理。`对CPU进行时间分割管理`的具体做法就叫做进程调度。

进程是资源分配的单位，线程是执行的单位。所以进程调度调度的是线程。

对线程的调度可以有两种方式：

- 直接调度线程，（称直接调度或者一级调度）
- 先调度进程，再在进程内部调度线程，（称间接调度或者二级调度）

POSIX规定，操作系统可以选择这两种方式中的任何一种都行。Linux选择的是一级调度，为什么？

- 主要是提高并发，充分利用多CPU多核的优势。一级调度可以使得 计算量小的进程少开线程，计算量大的进程多开线程。

Linux也推出了cgroup组调度机制，来限制某个或者某一类进程对CPU资源的过度占用。后文都是假设没有cgroup组调度。

### 1.2. 为什么要调度

有了调度就有了多任务，电脑体验会非常好。

- 程序运行过程中等待IO，CPU只能空转，浪费CPU资源
- 程序一直做运算，就会一直霸占CPU

所以需要抢占，抢占分为：

- 用户抢占。
- 内核抢占。由config选项控制。开启会提高系统的响应性但降低性能，关闭会提高性能但降低响应性。

### 1.3. 如何调度？

- 主动调度。由进程触发
- 被动调度。由中断触发

执行调度分：

- 选择进程，就是调度算法了；
- 切换进程：分两步，切换用户空间、切换执行栈（线程栈）
	- 切换用户空间：是CPU架构的事情，在x86 CPU上是给CR3寄存器赋值新进程的页表树的根指针。
	- 切换线程的内核栈：保存了线程的用户栈信息

### 1.4. 调度均衡

多个CPU之间会进行调度均衡，分：个体均衡、总体均衡。

- 个体均衡：是从进程的角度出发选择到一个相对清闲的CPU上去运行。有三个触发点：
	- 一是新进程刚创建时；
	- 二是进程要执行新程序时；
	- 三是进程被唤醒时；
- 总体均衡：是从CPU的角度出发如何从别的CPU上拉取一些进程到自己这来执行，使得所有CPU的工作量尽量平均。有三个触发点：
	- 一是CPU即将idle前会去找到最忙的CPU然后拉取一些任务过来；
	- 二是定时器中断的周期性检测，会检查是否所有的CPU都一样忙，如果忙闲差别太大就会进行进程迁移，使得所有CPU忙闲程度接近；
	- 三是在idle进程中如果CPU发现自己太忙而有的CPU在idle就会唤醒那个CPU进行负载均衡。

### 1.5. 调度器评价指标

- 响应性
- 吞吐量
- 公平性
- 适应性：指的是系统无论是调度几个进程还是调度几万个进程，都能撑得住，都能收放自如，各项指标都不能受到太大的影响。
- 节能性：省电

## 2. 框架

![进程状态](./_img/process_1.png)

### 2.1. CPU调度队列

每个CPU需要一个运行队列来安放所有就绪进程

```c
// per-CPU runqueue data structure
struct rq {
	unsigned int		nr_running;

	struct cfs_rq		cfs;	// 完全公平调度队列
	struct rt_rq		rt;		// 实时调度队列
	struct dl_rq		dl;		// 限时调度队列

	struct task_struct __rcu	*curr;
	struct task_struct	*idle;	// 闲时调度，（每个CPU只能有一个进程，无需队列）
	struct task_struct	*stop;	// 禁令调度，（每个CPU只能有一个进程，无需队列）
};

DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
```

### 2.2. 进程唤醒

进程是通过`进程唤醒`来放入运行队列的。

```c
// 新建唤醒
wake_up_new_task
	select_task_rq // 选择到哪个CPU的运行队列
	activate_task  // 把进程放入目标队列
	check_preempt_curr // 检查是否需要抢占
```

```c
// 阻塞唤醒
try_to_wake_up
	if (p == current) // 先检测被唤醒的进程是否为当前进程
		goto out
	select_task_rq // 选择到哪个CPU的运行队列
	ttwu_queue     // 把进程放入目标队列
	check_preempt_curr // 检查是否需要抢占
```

### 2.3. 调度时机

进程放入运行队列之后就等着被调度到CPU上去运行了。

当前进程正在使用CPU，它什么时候让出CPU给其他进程呢？两种情况：

- 一是当前进程主动让出CPU，这叫主动调度；
- 二是当前进程被动让出CPU，这叫被动调度，也就是进程抢占。

#### 2.3.1. 主动调度

- 自愿性主动调度，指进程主动调用sched_yield让出CPU；
- 非自愿性主动调度，指进程运行时遇到了无法继续运行的情况（加锁失败，要读的文件现在不在内存中、进程死亡），只能进行调度让其它进程运行。

如下，信号量，
```c
static inline int __sched __down_common(struct semaphore *sem, long state,
								long timeout)
{
	struct semaphore_waiter waiter;

	list_add_tail(&waiter.list, &sem->wait_list);
	waiter.task = current;
	waiter.up = false;

	for (;;) {
		if (signal_pending_state(state, current))
			goto interrupted;
		if (unlikely(timeout <= 0))
			goto timed_out;
		__set_current_state(state);
		raw_spin_unlock_irq(&sem->lock);
		timeout = schedule_timeout(timeout);
		raw_spin_lock_irq(&sem->lock);
		if (waiter.up)
			return 0;
	}

 timed_out:
	list_del(&waiter.list);
	return -ETIME;

 interrupted:
	list_del(&waiter.list);
	return -EINTR;
}
```
先定义一个等待项，把自己加入到信号量的等待列表中，然后调用schedule_timeout执行调度。

#### 2.3.2. 被动调度

被动调度的过程分为两步：`触发调度` 和 `执行调度`。

触发调度仅仅是做个标记，告诉系统需要调度了。
执行调度是系统会在某些特定的点去检查调度标记，如果被设置的话就执行调度。

触发调度的点有：

- 定时器中断；
- 唤醒进程时；
- 迁移进程时；
- 改变进程优先级时

执行调度的点有：

- 从系统调用返回用户空间；
- 从中断返回用户空间；
- 从中断返回内核空间；
- 禁用抢占临界区结束；
- 禁用软中断临界区结束；
- cond_resched调用点

##### 2.3.2.1. 定时器中断

```c
scheduler_tick
	// 调用当前进程的调度类的task_tick函数，此函数可能会触发调度
	curr->sched_class->task_tick(rq, curr, 0);
```

##### 2.3.2.2. 唤醒进程

上面的新建唤醒还是阻塞唤醒，最终都是调用check_preempt_curr函数：
```c
void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
{
	if (p->sched_class == rq->curr->sched_class)
		// 被唤醒的进程和当前进程是同一个调度类的则会调用调度类的函数来处理
		rq->curr->sched_class->check_preempt_curr(rq, p, flags);
	else if (p->sched_class > rq->curr->sched_class)
		// 被唤醒的进程比当前进程的调度类高，则会触发调度。
		resched_curr(rq);
}

resched_curr
	set_tsk_need_resched
		// 在thread_info的flag中设置TIF_NEED_RESCHED标记。
		set_tsk_thread_flag(tsk,TIF_NEED_RESCHED);
```

##### 2.3.2.3. 系统调用返回用户空间

以x86为例：
```c
do_syscall_64
	syscall_exit_to_user_mode
		__syscall_exit_to_user_mode_work
			exit_to_user_mode_prepare
				exit_to_user_mode_loop

static unsigned long exit_to_user_mode_loop(struct pt_regs *regs,
					    unsigned long ti_work)
{
	if (ti_work & _TIF_NEED_RESCHED)
		schedule();
}
```
系统调用完成之后返回用户空间之前会检测thread_info flag中的_TIF_NEED_RESCHED，如果设置了就会执行调度。

##### 2.3.2.4. 中断返回用户空间或者内核空间

所有中断和异常的入口函数, 其中一定会调用irqentry_exit
```c
#define DEFINE_IDTENTRY_IRQ(func)        \
	...
	irqentry_exit(regs, state);          \
	...

#define DEFINE_IDTENTRY(func)         \
	...
	irqentry_exit(regs, state);       \
	...
```

```c
irqentry_exit
	// 根据寄存器状态，判断返回到用户空间还是内核空间
	
	// 返回到用户空间
	irqentry_exit_to_user_mode
		exit_to_user_mode_prepare
			exit_to_user_mode_loop
				schedule

	// 返回到内核空间
	irqentry_exit_cond_resched
		// 是否可以内核抢占
		if (!preempt_count())
			preempt_schedule_irq
```

##### 2.3.2.5. 禁用抢占临界区结束

preempt_disable增加引用计数，preempt_enable减少引用计数并检测是否为0，如果为0则执行调度。

```c
#define preempt_disable() \
do { \
	preempt_count_inc(); \
	barrier(); \
} while (0)

#define preempt_enable() \
do { \
	barrier(); \
	if (unlikely(preempt_count_dec_and_test())) \
		__preempt_schedule(); \
} while (0)
```


##### 2.3.2.6. 禁用软中断临界区结束

```c
local_bh_enable
	__local_bh_enable_ip
		preempt_count_dec
		preempt_check_resched
			__preempt_schedule
```

##### 2.3.2.7. cond_resched调用点

在很多比较耗时的内核操作中都会加上cond_resched调用，用来增加抢占调度的检测点，提高系统的响应性。

```c
cond_resched
	_cond_resched
		__cond_resched
			preempt_schedule_common
```

### 2.4. 调度流程

执行调度，就两个步骤：选择进程和切换进程。

```c
__schedule
	pick_next_task  // 选择下一个要执行的进程，涉及调度算法
	context_switch  // 切换进程
```

#### 2.4.1. 调度算法

![调度算法](./_img/process_2.png)

Linux中一共有五个调度类，分别是：

- stop (禁令调度类)
- deadline (限时调度类)
- realtime (实时调度类)
- time-share (分时调度类)
- idle (闲时调度类)

它们的调度紧迫性从上到下，依次降低。其中禁令调度类和闲时调度类有特殊的目的，仅用于内核，没有调度策略，由于这类进程在内核启动时就设置好了，一个CPU一个相应的进程，所以也不需要调度算法。

另外三个调度类可用于用户空间进程，有相应的调度策略和调度算法，也有相应的API供用户空间来设置一个进程的调度策略和优先级。

内核为了防止实时进程饿死普通进程，提供了一个配置参数，默认值是实时进程如果已经占用了95%的CPU时间，就会把剩余5%的CPU时间分给普通进程。

##### 2.4.1.1. 禁令调度类

